#!/usr/bin/perl
# 
# This program is intended to be a high-level programming language and
# code generator with heavy emphasis on regular expressions
# and anticipated use in data scraping.
#
# It currently compiles down to Python 3.
#
# Design priorities:
# - Short, readable code
# - Ease of learning
# - Modelled after natural English usage
# - Experimental introduction of "contexts" to replace/unify flow control and parameters
#
#
# Copyright (C) 2020, 2021 Philipp L. Wesche
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License v3 (version 3),
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# To contact me, find my contact details via my personal website.

use strict;
use sigtrap;
use Getopt::Long;

my $outputProgLang = '';
GetOptions ("code=s" => \$outputProgLang);

open IN, $ARGV[0];
chomp(my @lines = <IN>);
my $preamble = "import re\n";
my $bracketOpener = '';
my $startingStatement = '';
my $stoppingStatement = '';
my $skippingStatement = '';
my $closingBrackets = "\n";
my $outputStatement = '';
my $nonChewCode = '';
my @vNames = ('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','r','s','t','u','v','w','x','y','z','aa','ab','ac','ad','ae','af','ag','ah','ai','aj','ak','al','am','an','ao','ap'); #interim solution
my $vindex = 0;   # put some... have you seen the movie?
if ($lines[0] =~ /^Reading /) {
	#TODO we probably want to silently chop trailing white space, or warn about it
	if ($lines[0] =~ /^Reading https?\:\/\//) {
		my $url = $lines[0];
		$url =~ s/^Reading //;
		$preamble .= "import requests\n"
			    ."import urllib.request\n"
			    ."url = '".$url."'\n"
			    ."headers = { 'User-Agent': 'Mozilla/5.0' }\n"
			    ."response = requests.get(url, headers=headers)\n"
			    ."if response.status_code != 200:\n"
			    ."\traise Exception(response.raise_for_status())\n" # this or sys.exit() or even SystemExit
			    ."lines = response.text.splitlines()\n";
	} else {
		my $readfile;
		$readfile = $lines[0];
		$readfile =~ s/^Reading //;
		$preamble .=  'filein = open("'.$readfile.'", "r")'."\n"
			     ."lines = filein.read().splitlines()\n";
	}
} else {
	die 'ERROR: No "Reading" instruction found in first line.'."\n";
}
if ($lines[@lines-1] =~ /^Output /) {
	for (my $i = 1; $i < @lines; $i++) {
		if ($lines[$i] =~ /^Outputting /) {
			die 'ERROR: Both Output and Outputting specified. Unclear what you want.'."\n";
		}
	}
} elsif ($lines[@lines-2] =~ /^Outputting /) {
} else {
	for (my $i = 1; $i < @lines; $i++) {
		if ($lines[$i] =~ /^Hand-over$/i) {
			$nonChewCode = join ("\n", @lines[($i+1)..(@lines-1)]);
			splice @lines, $i+1, (@lines-$i);   # removing non-chew lines early to avoid errors later
			last;
		}
		if ($i == (@lines-1)) {
			die "ERROR: Neither output format nor hand-over were specified. Must have at least one.\n";
		}
	}
}
my $outputFormat;
$outputFormat = (split /^Output /, $lines[@lines-1])[1];

my $curVName = $vNames[$vindex];
$vindex++;
my $splitNum = 1;
$preamble .=    "processing = 0\n"
	       ."capturedData = {}\n";
$bracketOpener .= "for $curVName in range(len(lines)):\n";
$closingBrackets = '';

my $indentLevel = 0;
my $hasStartStatement = 0;
my $isMatchStillOpen = 0;
my %stillAllowed = ('Starting',1,'Stopping',1); # only one of each of these #TODO
my %requireOneOf = ('Starting',1,'Stopping',1,'Matching',1,'Cutting',1); #TODO
my @fieldNames;
my $regex;

# detect the indenting pattern used in the chew file
my $indentPattern = '';
my $firstIndentLine;
for (my $i = 1; $i < (@lines-1); $i++) {
	if ($lines[$i] =~ /^\s/) {
		$firstIndentLine = $i;
		my @linechars = split //, $lines[$i];
		for (my $a = 0; $a < @linechars; $a++) {
			if ($linechars[$a] =~ /\s/) {
				$indentPattern .= $linechars[$a];
			} else {
				last;
			}
		}
		last;
	}
}

# for now and for simplicity, enforce that only one whitespace character be used
my $indentLength = length($indentPattern);
my @indentSplit = split //, $indentPattern;
if ($indentLength > 1) {
	for (my $j = 1; $j < @indentSplit; $j++) {
		if ($indentSplit[$j] ne $indentSplit[$j-1]) {
			die 'ERROR: There was a mix of different whitespace characters used at the first indent, on line '.$firstIndentLine.'. Please use the same whitespace character for all indenting (space or tab, not both).'."\n";
		}
	}
}
my $indentChar = $indentSplit[0];

my @indentDepth;
for (my $i = 0; $i < @lines; $i++) {
	if ($lines[$i] =~ /^$indentChar+/) {
		my $rawIndentLen = length( substr ( $lines[$i], $-[0], $+[0]-$-[0] ) );
		if ($rawIndentLen % $indentLength) {
			die 'ERROR: Indent length on line '.($i+1).' is not a multiple of the indent length defined in the first indented line, line '.($firstIndentLine+1).".\n";
		} else {
			$indentDepth[$i] = $rawIndentLen / $indentLength;	
		}
	} else {
		$indentDepth[$i] = 0;
	}
}
#check indents are increasing only one step at a time
for (my $i = 1; $i < @lines; $i++) {
	if  ( $indentDepth[$i]  >  ( $indentDepth[$i-1] + 1 )  )  {
		die 'ERROR: Excessive indenting on line '.($i+1).'. Unexpected application behaviour may result.'."\n";
	}
}
my $outputAdditionalIndents = 0;
my $indentStr = "\t";
for (my $i = 1; $i < (@lines-1); $i++) {
	if      ($lines[$i] =~ /^\s*Starting at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Starting at', $lines[$i]);
			$startingStatement .= "\tif re.search(r'".$regex."', lines[".$curVName."]):\n"
					     ."\t\tprocessing = 1\n"
					     ."\tif (processing == 1):\n";
			$closingBrackets = ''.$closingBrackets;
			$outputAdditionalIndents++;
			$hasStartStatement = 1;
		} else {
			die 'ERROR: Illegal end to "Starting" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Stopping at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Stopping at', $lines[$i]);
			$stoppingStatement .= "\tif re.search(r'".$regex."', lines[".$curVName."]):\n"
						   ."\t\tbreak\n";
		} else {
			die 'ERROR: Illegal end to "Stopping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Skipping [1-9][0-9]* whenever \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = $lines[$i];
			$regex =~ s/^\s*Skipping [1-9][0-9]* whenever \///;
			$regex =~ s/\/$//;
			$regex = sanitiseRegex($regex);
			my @array = split /Skipping | whenever /, $lines[$i];
			my $extraInd = $indentStr x $outputAdditionalIndents;
			$startingStatement .= $extraInd."\t".'if (';
			if ($hasStartStatement) {
				$startingStatement .= 'processing == 1 and '
			}
			$startingStatement .= "re.search(r'".$regex."', lines[".$curVName."]) ):\n"
					     .$extraInd."\t\t$curVName += ".$array[1]."\n";
		} else {
			die 'ERROR: Illegal end to "Skipping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Matching \//) {   # probably the least useful context
						      # as Splitting can usually do its job
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Matching',$lines[$i]);
			my $extraInd = $indentStr x $outputAdditionalIndents;
			$startingStatement .= $extraInd."\t".'if (';
			if ($hasStartStatement) {
				$startingStatement .= 'processing == 1 and '
			}
			$startingStatement .= "re.search(r'".$regex."', lines[".$curVName."]) ):\n";
			$closingBrackets = ''.$closingBrackets;
			$outputAdditionalIndents++;
			$isMatchStillOpen = 1; # matching must be followed by cut (or take?)
		} else {
			die 'ERROR: Illegal end to "Matching" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Capture \//) {
		if ($lines[$i] =~ /\/ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array1 = split /Capture \//, $lines[$i];
			my @array2 = split /\/ as /, $array1[1];
			my $regex = join '/ as ', @array2[0..(@array2-2)];
			$regex = sanitiseRegex($regex);
			push @fieldNames, $array2[$#array2];
			$startingStatement .= "\t".'if re.search(r'".$regex."', lines[".$curVName."]):'."\n"
					     ."\t\t".'capturedData["'.$array2[$#array2].'"].append([ re.findall('."r'$regex'".', s)[0] ]}'."\n";
		} else {
			die 'ERROR: Illegal end to "Capture" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Splitting at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Splitting at',$lines[$i]);
			my $masterIndent = $indentDepth[$i];
			my $takeChunkOutputCode;
			for (my $j = $i+1; $j < @lines; $j++) {
				if ($indentDepth[$j] <= $masterIndent) {
					my @focusLines = @lines[($i+1)..($j-1)];
					my @focusIndents = @indentDepth[($i+1)..($j-1)];
					($takeChunkOutputCode, my @tempFieldNames) = processTakeChunk(($i+1), $splitNum, \@focusLines, \@focusIndents);
					push @fieldNames, @tempFieldNames;
					$i = $j-1;
					last;
				}
			}
			$startingStatement .= "\t\tif re.search(r'".$regex."', lines[".$curVName."]):\n"
					     ."\t\t\t".'array'.$splitNum." = re.split(r'".$regex."'".', lines['.$curVName.'])'."\n";
			$startingStatement .= $takeChunkOutputCode.'';
			$splitNum++;
		} else {
			die 'ERROR: Illegal end to "Splitting" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Locating around \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Locating around', $lines[$i]);
			$startingStatement .= "\tif re.search(r'".$regex."', lines[".$curVName."]):\n";
			my $masterIndent = $indentDepth[$i];
			my $atChunkOutputCode;
			for (my $j = $i+1; $j < @lines; $j++) {
				if ($indentDepth[$j] <= $masterIndent) {
					my @focusLines = @lines[($i+1)..($j-1)];
					my @focusIndents = @indentDepth[($i+1)..($j-1)];
					($atChunkOutputCode, $splitNum, my @tempFieldNames) = processAtChunk(($i+1), $splitNum, $curVName, \@focusLines, \@focusIndents);
					$startingStatement .= $atChunkOutputCode;
					push @fieldNames, @tempFieldNames;
					$i = $j-1;
					last;
				}
			}
		} elsif ($lines[$i] =~ /^Hand-over$/i) {
			last;
		} else {
			die 'ERROR: Illegal end to "Locating" statement on line '.($i+1).".\n";
		}
	} else {
		die 'ERROR: Line '.($i+1).' did not match any expected expression (Starting, Stopping, Matching, Splitting, Capture).'."\n";
	}
}

# CONSTRUCTING OUTPUT
#TODO optional warning if output columns are unbalanced
if (@fieldNames) {
	$preamble .= 'fieldNames = ["'.$fieldNames[0].'"';
	for (my $i = 1; $i < @fieldNames; $i++) {
		$preamble .= ',"'.$fieldNames[$i].'"';
	}
	$preamble .= "]\n";
	for (my $i = 0; $i < @fieldNames; $i++) {
		$preamble .= 'capturedData["'.$fieldNames[$i].'"] = []'."\n";
	}
}
unless ($nonChewCode) {
	$outputStatement = 'outputLines = []'."\n"
			  .'outputRowCount = 0'."\n"
			  .'for field in fieldNames:'."\n"
			  .'  if ( outputRowCount < len(capturedData[field]) ):'."\n"
			  .'    outputRowCount = len(capturedData[field])'."\n"
			  ."\n"
			  .'for i in range(outputRowCount):'."\n"
			  .'  outputLines.append("")'."\n"
			  ."\n"
			  .'for i in range(outputRowCount):'."\n"
			  .'  for field in fieldNames:'."\n"
			  .'    if ( i < len(capturedData[field])):'."\n"
			  .'      outputLines[i] = outputLines[i] + str(capturedData[field][i][0])'."\n"
			  .'    outputLines[i] = outputLines[i] + "\t"'."\n"    # prevent column slippage by inserting tab even if no data for this col
			  .'fieldString = ""'."\n"
			  .'for field in fieldNames:'."\n"
			  .'  fieldString = fieldString + field + "\t"'."\n"
			  .'print(fieldString)'."\n"
			  .'for line in outputLines:'."\n"
			  .'  print(line)';
}
my $output = $preamble.$bracketOpener.$stoppingStatement.$startingStatement.$skippingStatement.$closingBrackets.$outputStatement.$nonChewCode;
if ($outputProgLang eq 'python3') {
	print $output;
	print "\n";
} elsif ($outputFormat eq 'tsv+header') { 
	open OUT, ">chewtempfile.py";
	print OUT $output;
	close OUT;
	system "python3 chewtempfile.py";
	unlink 'chewtempfile.py';
} else {
	die "ERROR: Output instructions absent or not recognised.\n";
}

# PARSING FUNCTIONS
sub processTakeChunk {
	my ($startLine,$splitNum,$ref1,$ref2) = @_;
	my @lines     = @$ref1;
	my @indentDepth   = @$ref2;
	my $outputVal = '';
	my @tempFieldNames;
	for (my $i = 0; $i < @lines; $i++) {
		if ($lines[$i] =~ /^\s*Take [0-9]+ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array = split /Take | as /, $lines[$i];
			push @tempFieldNames, $array[2];
			$outputVal .= "\t\t\t".'capturedData["'.$array[2].'"].append([ array'.$splitNum.'['.$array[1].'] ])'."\n"; #TODO do we need if(defined()) type magic for python?
		} else {
			# TODO add other possibilities, like Splitting further
			die 'ERROR: Correctly formatted Take statement expected on line '.($startLine+$i+1).".\n";
		}
	}
	return ($outputVal, @tempFieldNames);
}
sub processAtChunk {
	my ($startLine,$splitNum,$curVName,$ref1,$ref2) = @_;
	my @lines     = @$ref1;	  # making a copy
	my @indentDepth   = @$ref2;   # making a copy
	my $outputVal = '';
	my @localFieldNames;
	unless ($lines[0] =~ /^\s+At ([+-]?[1-9]\d*|0)$/) {
		die 'At statement expected on line '.($startLine+1).".\n";
	}
	for (my $i = 0; $i < @lines; $i++) {
		if ($lines[$i] =~ /^\s*(At) /) {
			my $lookWhere = $lines[$i];
			$lookWhere =~ s/^\s*At //;
			my $masterIndent = $indentDepth[$i];
			for (my $j = $i+1; $j < @lines; $j++) {
				if ($indentDepth[$j] > $masterIndent) {
					if ($lines[$j] =~ /^\s*Splitting /) {
						my $regex2 = extractRegex('Splitting at', $lines[$j]);
						my $nextMasterIndent = $indentDepth[$j];
						my $takeChunkOutputCode;
						for (my $k = $j+1; $k < @lines; $k++) {
							if ($k == $#lines) {
								my @focusLines   =       @lines[($j+1)..$k];
								my @focusIndents = @indentDepth[($j+1)..$k];
								($takeChunkOutputCode, my @tempFieldNames) = processTakeChunk(($i+1), $splitNum, \@focusLines, \@focusIndents);
								push @localFieldNames, @tempFieldNames;
								$j = $k;
								last;
							} elsif ($indentDepth[$k] <= $masterIndent) {
								my @focusLines   =       @lines[($j+1)..($k-1)];
								my @focusIndents = @indentDepth[($j+1)..($k-1)];
								($takeChunkOutputCode, my @tempFieldNames) = processTakeChunk(($i+1), $splitNum, \@focusLines, \@focusIndents);
								push @localFieldNames, @tempFieldNames;
								$j = $k - 1;
								last;
							}
						}
						my $before = "\t\tif re.search(r'".$regex2."', lines[".$curVName.'+'.$lookWhere."]):\n"
					                    ."\t\t\t".'array'.$splitNum." = re.split(r'".$regex2."'".', lines['.$curVName.'+'.$lookWhere."])\n";
						my $after  = '';
						$outputVal .= $before.$takeChunkOutputCode.$after;
						$splitNum++;
					} elsif ($lines[$i+2] =~ /^\s*Matching /) {
						#TODO
					}
				} else {
					$i = $j - 1;
					last;
				}
			}
		#} else {
			#die 'ERROR: "Locating" on line '.($i+1).' must be followed by "At" statements.'."\n";
		}
	}
	return ($outputVal,$splitNum,@localFieldNames);
}
# AUXILIARY FUNCTIONS
sub extractRegex {
	$_[1] =~ s/^\s*$_[0] \///;
	$_[1] =~ s/\/$//;
	return sanitiseRegex($_[1]);
}
sub sanitiseRegex {
	my @chars = split //, $_[0];
	if ($chars[0] eq '/') {
		$chars[0] = '\/';
	}
	my @active;
	for (my $i = 0; $i < (@chars-1); $i++) {
		if ($chars[$i] =~ /\\/ && $chars[$i+1] =~ /^\\$/) {
			$active[$i] = 0;
			$active[$i+1] = 0;
			$i++;
		} else {
			$active[$i] = 1;
		}
	}
	for (my $i = 1; $i < @chars; $i++) {
		if ($chars[$i] eq '/') {
			unless ($active[$i-1] == 1 && $chars[($i-1)] =~ /^\\$/ ) {
				$chars[$i] = '\/';
			}
		}
	}
	return (join ('', @chars));
}
